#pragma config(StandardModel, "EV3_REMBOT")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#pragma config(StandardModel, "EV3_REMBOT")
////////STACK////////
#define MaxEl 8
#define Nil 0
typedef struct {
	int T[MaxEl+1];
	int TOP;
} Stack;
#define Top(S) (S).TOP
#define InfoTop(S) (S).T[(S).TOP]
void CreateEmpty(Stack *S) {
	Top(*S)=Nil;
}
int IsEmpty(Stack S) {
	return Top(S)==Nil;
}
int IsFull(Stack S) {
	return Top(S)==MaxEl;
}
void Push(Stack *S,int X) {
	Top(*S)++;
	InfoTop(*S)= X;
}
void Pop(Stack *S,int *X) {
	(*X)=InfoTop(*S);
	Top(*S)--;
}
void InsertAtBottom(Stack *S,int x) {
	int temp;
	if(IsEmpty(*S))
		Push(S,x);
	else {
		Pop(S,&temp);
		InsertAtBottom(S,x);
		Push(S,temp);
	}
}
/////////////////////
#define red 1
#define green 0
void searchSpot(int color) {
	int hue;
	int threshold = 65;
	moveMotorTarget(leftMotor,360,100);
	moveMotorTarget(rightMotor,360,100);
	while(getMotorMoving(leftMotor)||getMotorMoving(rightMotor))
		sleep(1);
	while(true)
	{
		// sensor sees light:
		if(getColorReflected(colorSensor) < threshold)
		{
			// counter-steer right:
			motor[leftMotor]  = 55;
			motor[rightMotor] = 15;
		}
		// sensor sees dark:
		else
		{
			// counter-steer left:
			motor[leftMotor]  = 15;
			motor[rightMotor] = 55;
		}
		hue=getColorHue(colorSensor);
		if((hue==99&&color==green)||(hue==253&&color==red)) break;
	}
}
#define left 0
#define right 1
#define straight -1
#define first -2
void turn(int dir,int deg) {
int l = dir==left?0:30;
int r = dir==right?0:30;
	setMotorSpeed(leftMotor,l);
	setMotorSpeed(rightMotor,r);
	while(getMotorMoving(leftMotor) || getMotorMoving(rightMotor)) {
		sleep(1);
		if((getGyroDegrees(gyroSensor)<deg && dir==left)
			||(getGyroDegrees(gyroSensor)>deg && dir==right))
		break;
	}
}
void setStraight() {
	int gyro=getGyroDegrees(gyroSensor);
int l=gyro?0:30;
int r=gyro?30:0;
	motor[leftMotor]=l;
	motor[rightMotor]=r;
	while(getMotorMoving(leftMotor)||getMotorMoving(rightMotor)) {
		sleep(1);
		if(getGyroDegrees(gyroSensor)==0)
			break;
	}
}
void stepAhead() {
	//setStraight();
	moveMotorTarget(leftMotor,220,50);
	moveMotorTarget(rightMotor,220,50);
	while(getMotorMoving(leftMotor)||getMotorMoving(rightMotor)) {
		sleep(1);
	}
}/*
void BFS(int dirBack,Stack *S) {
	int x,y,degree;
	if(IsEmpty(*S)) {}
	else {
		searchSpot(green);
		Pop(S,&x);
		switch(dirBack) {
		case right:
		y=(x==straight)?right:straight;
			break;
		case straight:
		y=(x==right)?left:right;
			break;
		case left:
		y=(x==straight)?left:straight;
			break;
		default:
			y=x; //first
		}
		if(y!=straight) {
			stepAhead();
		degree=(y==right)?85:-80;
			turn(y,degree);
		}
		searchSpot(red);
		resetGyro(gyroSensor);
		turn(1,180);
		BFS(x,S);
	}
}*/
void BFS() {

}
task main()
{
	Stack S;
	CreateEmpty(&S);
	int route[] = {1,-1,1,0,1,0,-1,0};
	int i=0;
	repeatUntil(IsFull(S)||i>2) {
		InsertAtBottom(&S,route[i++]);
	}
	while(1){
		searchSpot(green);
		stepAhead();
		resetGyro(gyroSensor);
		turn(right,85);
		searchSpot(red);
		resetGyro(gyroSensor);
		turn(right,180);}
}
